## 第九章 动态规划基础

### 记忆化搜索

- 在递归函数中计入memo，进行记忆
- 自上向下的解决问题
  - 假设基础问题已经解决
  - 一般自上向下能解决，那么自下向上也能截距
  - 但是自上向下更加简单

### 动态规划

- 自下向上进行解决问题
  - 先解决小问题，然后再解决大问题

- 将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求一次

- 大多数动态规划问题都是递归问题，只不过再递归中存在重叠子问题
  - 记忆化搜索(自顶向下的解决问题)
    - 一般实际上记忆化搜索就能满足需求了
  - 动态规划(自底向上的解决问题)

- 最优子结构
  - 子问题的最优解组合后就是父问题的最优解

- 参考：[DP IS EASY! 5 Steps to Think Through DP Questions. - LeetCode Discuss](https://leetcode.com/problems/target-sum/discuss/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions.)
  - [[DP is Easy!] 5 Step DP THINKING process EXPLAINED! - LeetCode Discuss](https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/discuss/654490/dp-is-easy-5-step-dp-thinking-process-explained)

#### 动态规划判断流程

- 原问题是否是递归问题？
- 是否存在重叠子问题？
- 是否是最优子结构？
  - 如果上述都符合，那么就可以使用记忆化搜索或者动态规划

#### 状态与状态转移
- 注意状态的定义(状态的定义实际上就相当于函数的定义。比如考虑从i开始的子数列)
- 然后列举出状态转移方程(就是为了解决最终的问题，应该对各个状态采取什么操作。求和，求最大值等等)
  - 状态方程需要传入的参数可以理解为约束条件。比如总和在n以内，总个数在n以内等等。存在多少个约束条件就要传入多少个参数。
- 状态图中有自己指向自己的一般都是要跟前一个状态比较
- dijkstra单源最短路径算法也是动态规划
  - shortestPath(i)为从start到i的最短路径长度
  - shortestPath(x) = min(shortestPath(a) + w(a->x))

#### 0-1背包问题
- F(n, C)考虑将n个物品放进容量为C的背包，使得价值最大
  - F(i, c) = max(F(i-1, c), v(i) + F(i - 1, c - w(i)))
  - 根据状态转移方程，可以看出需要的元素只是上一行的元素，所以只需要两行空间即可。也就是看的行数是偶数还是奇数
  - 并且如果只保存一行元素，并且从右向左更新的话，只需要一行空间即可
  - 最外层循环次数看n(看元素个数)，内部动态规划数组维度看C(约束条件)
- 变种
  - 完全背包问题：每个物品可以无限使用
    - 因为背包容量是有限的，可以计算出可以使用的最大次数即可。
    - 因为在外层循环次数使根据元素个数订的，所以这个时候无法通过元素个数决定循环次数。应该每一次准确计算一个值，通过动态规划数组的大小进行计算
  - 多重背包问题：每个物品有特定最大次数
  - 多维费用背包问题：要考虑物品的体积和重量两个维度
    - 参数变多，动态规划的时候数组需要升维
  - 物品间增加约束：互相排斥，互相依赖
    - 此时在维护数组的时候需要将互相排斥，互相依赖等关系纳入讨论


#### 最长公共子序列
- LCS(m, n), S1\[0...m]和S2\[0...n]的最长公共子序列
  - S1\[m] == S2\[n]
    - LCS(m, n) = 1+LCS(m - 1,n - 1)
  - S1\[m] != S2\[n]
    - LCS(m, n) = max(LCS(m-1, n), LCS(m, n-1))

#### 动态规划给出具体解
- 重构的时候需要反向查找计算出结果的路径即可
- 在重构的时候需要之前所有的信息，这个时候不能对空间进行过度优化

